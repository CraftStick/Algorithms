# Sliding Window Minimum (Минимум в скользящем окне)

| | |
| :--- | :--- |
| **Input** | Standard input |
| **Output** | Standard output |

### Problem Statement
Consider a sequence of $N$ integers. A "window" of length $K$ moves along this sequence with a step of 1. Initially, the window contains the first $K$ numbers. At the next step, it contains $K$ numbers starting from the second one, and so on until the end of the sequence. For each position of the window, you need to determine the minimum value within it.

### Input Format
- The first line contains two integers $N$ and $K$ ($1 \le N \le 150,000$, $1 \le K \le 10,000$, $K \le N$) — the length of the sequence and the window size, respectively.
- The second line contains $N$ integers — the sequence itself. All numbers are integers and do not exceed $10^9$ in absolute value.

### Output Format
The output should contain $N - K + 1$ lines — the minimum value for each window position.

### Examples
| Input | Output |
| :--- | :--- |
| `7 3` <br> `1 3 2 4 5 3 1` | `1` <br> `2` <br> `2` <br> `3` <br> `1` |

#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;

int k, heapSize;
int heap[150000];
int a[150000];
int where[150000];

void heap_swap(int c, int b) {
    swap(heap[c], heap[b]);
    where[heap[c]] = c;
    where[heap[b]] = b;
}

void siftUp(int v) {
    while ((v > 0) && (a[heap[v]] < a[heap[(v - 1) / 2]])) {
        heap_swap(v, (v - 1) / 2);
        v = (v - 1) / 2;
    }
}

void siftDown(int v) {
    while (2 * v + 1 < heapSize) {
        int left = 2 * v + 1;
        int right = 2 * v + 2;
        int minCh = left;
        if ((right < heapSize) && (a[heap[right]] < a[heap[left]]))
            minCh = right;
        if (a[heap[v]] <= a[heap[minCh]])
            return;
        heap_swap(v, minCh);
        v = minCh;
    }
}

int extractMin() {
    int t = heap[0];
    heap_swap(0, heapSize - 1);
    --heapSize;
    where[t] = -1;
    siftDown(0);
    return t;
}

void erase(int x) {
    if (where[x] != -1) {
      a[x] = pow(-10,9)-1;
      siftUp(where[x]);
      extractMin();
    }
}

int getMin() {
    return a[heap[0]];
}

void insert(int x) {
    heap[heapSize++] = x;
    where[x] = heapSize - 1;
    siftUp(heapSize - 1);
}

int main() {
    int n;
    cin >> n >> k;
    for (int i = 0; i < n; ++i) cin >> a[i];
    int r = k, l = 0;
    for (int i = 0; i < k; ++i)
        insert(i);
    while (r <= n) {
        cout << getMin() << endl;
        if (r < n) {
            insert(r);
        }
        erase(l);
        l++; 
        r++;
    }
  return 0;
}
