# 1. Undirected Graph Check (Проверка на неориентированность)

| | |
| :--- | :--- |
| **Score** | 100 / 100 |
| **Verification** | Automatic |
| **Input** | Standard input |
| **Output** | Standard output |
| **Time Limit** | 2 seconds |
| **Memory Limit** | 64 megabytes |

### Problem Statement
Given a square $n \times n$ matrix of zeros and ones, determine whether this matrix can be the adjacency matrix of a **simple undirected graph**. 

A **simple graph** is a graph that contains no loops (edges connecting a vertex to itself) and no multiple edges.

### Input Format
- The first line contains an integer $n$ ($1 \le n \le 100$) — the size of the matrix.
- The following $n$ lines contain $n$ numbers each (0 or 1) — the matrix elements.

### Output Format
Print **YES** if the given matrix can be the adjacency matrix of a simple undirected graph, and **NO** otherwise.

### Examples
| Input | Output |
| :--- | :--- |
| `3` <br> `0 1 1` <br> `1 0 1` <br> `1 1 0` | `YES` |
| `3` <br> `0 1 0` <br> `1 0 1` <br> `1 1 0` | `NO` |

#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<vector<int>> matrik;
    for (int i = 0; i < n; i++) {
        vector<int> row;
        for (int j = 0; j < n; j++) {
            int value;
            cin >> value;
            row.push_back(value);
        }
        matrik.push_back(row);
    }
    for (int i = 0; i < n; i++) {
        if (matrik[i][i] != 0) {
            cout << "NO" << endl;
            return 0;
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (matrik[i][j] != matrik[j][i]) {
                cout << "NO" << endl;
                return 0;
            }
        }
    }
    
    cout << "YES" << endl;
    return 0;
}


# Self-Loop Check (Проверка на петли)

| | |
| :--- | :--- |
| **Input** | Standard input |
| **Output** | Standard output |

### Problem Statement
Given the adjacency matrix of an undirected graph, determine whether it contains any **self-loops**. 

A self-loop is an edge that connects a vertex to itself. In an adjacency matrix, a self-loop at vertex $i$ is represented by a non-zero value on the main diagonal ($A_{ii} = 1$).

### Input Format
- The first line contains an integer $n$ ($1 \le n \le 100$) — the number of vertices in the graph.
- The following $n$ lines contain $n$ integers each (0 or 1) — the adjacency matrix.

### Output Format
Print **YES** if the graph contains at least one self-loop, and **NO** otherwise.

### Examples
| Input | Output |
| :--- | :--- |
| `3` <br> `0 1 1` <br> `1 0 1` <br> `1 1 0` | `NO` |
| `3` <br> `0 1 0` <br> `1 1 1` <br> `0 1 0` | `YES` |

#include <iostream>
#include <vector>

using namespace std;

int main(){
    int n;
    cin >> n;
    
    vector<vector<int>> matrik;
    
    for(int i = 0; i < n; i++) { 
        vector<int> row;
        for (int j = 0; j < n; j++){
            int x;
            cin >> x;
            row.push_back(x);
        }
        matrik.push_back(row); 
    }
    for(int i = 0; i < n; i++) { 
        if (matrik[i][i] == 1){
            cout << "YES" << endl;
            return 0; 
        }
    }
    cout << "NO" << endl;
    return 0;
}


# Adjacency Matrix to Edge List (Матрица смежности в список ребер)

| | |
| :--- | :--- |
| **Input** | Standard input |
| **Output** | Standard output |

### Problem Statement
A simple undirected graph is given by its adjacency matrix. Your task is to output its representation as an **edge list**.

### Input Format
- The first line contains an integer $n$ ($1 \le n \le 100$) — the number of vertices in the graph.
- The following $n$ lines contain $n$ integers each (0 or 1) — the adjacency matrix of the graph.

### Output Format
Print the list of edges of the given graph. Each edge should be represented by the indices of the two vertices it connects. The edges can be printed in any order.

### Examples
| Input | Output |
| :--- | :--- |
| `3` <br> `0 1 1` <br> `1 0 1` <br> `1 1 0` | `1 2` <br> `2 3` <br> `1 3` |

#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<vector<int>> matrix;
    for (int i = 0; i < n; i++) {
        vector<int> row;
        for (int j = 0; j < n; j++) {
            int x;
            cin >> x;
            row.push_back(x);
        }
        matrix.push_back(row);
    }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) { 
            if (matrix[i][j] == 1) {
                cout << i + 1 << " " << j + 1 << endl;
            }
        }
    }
    return 0;
}


# Edge List to Adjacency Matrix (Список ребер в матрицу смежности)

| | |
| :--- | :--- |
| **Input** | Standard input |
| **Output** | Standard output |
| **Time Limit** | 2 seconds |
| **Memory Limit** | 64 megabytes |

### Problem Statement
A simple undirected graph is given as an edge list. Your task is to output its representation as an **adjacency matrix**.

### Input Format
- The first line contains two integers: $n$ ($1 \le n \le 100$) — the number of vertices, and $m$ ($1 \le m \le \frac{n(n-1)}{2}$) — the number of edges.
- The following $m$ lines each contain a pair of integers representing an edge in the graph.

### Output Format
Print the $n \times n$ adjacency matrix of the graph.

### Examples
| Input | Output |
| :--- | :--- |
| `3 3` <br> `1 2` <br> `2 3` <br> `1 3` | `0 1 1` <br> `1 0 1` <br> `1 1 0` |
| `5 3` <br> `1 3` <br> `2 3` <br> `2 5` | `0 0 1 0 0` <br> `0 0 1 0 1` <br> `1 1 0 0 0` <br> `0 0 0 0 0` <br> `0 1 0 0 0` |

#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> matrix;
    for (int i = 0; i < n; i++) {
        vector<int> row;
        for (int j = 0; j < n; j++) {
            row.push_back(0); 
        }
        matrix.push_back(row);
    }
   
    for (int k = 0; k < m; k++) {
        int u, v;
        cin >> u >> v;
        u--; v--; 
        matrix[u][v] = 1;
        matrix[v][u] = 1;
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}


# Vertex Degrees (Степени вершин)

| | |
| :--- | :--- |
| **Input** | Standard input |
| **Output** | Standard output |

### Problem Statement
An undirected graph is given by its adjacency matrix. Find the degrees of all vertices in the graph.

### Input Format
- The first line contains an integer $n$ ($1 \le n \le 100$) — the number of vertices in the graph.
- The following $n$ lines contain the $n \times n$ adjacency matrix (each element is 0 or 1).

### Output Format
Print $n$ integers — the degrees of the vertices of the graph.

### Notes
The **degree of a vertex** is the number of edges incident to that vertex.

### Examples
| Input | Output |
| :--- | :--- |
| `3` <br> `0 1 0` <br> `1 0 1` <br> `0 1 0` | `1` <br> `2` <br> `1` |

#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n;
    cin >> n;
    vector<vector<int>> matrix;
    for (int i = 0; i < n; i++) {
        vector<int> row;
        for (int j = 0; j < n; j++) {
          int x;
          cin >> x;
            row.push_back(x); 
        }
        matrix.push_back(row);
    }
  for (int i = 0; i < n; i++){
     int a = 0;
  for(int j = 0; j < n; j++){
    a += matrix[i][j];
  }
    cout << a << endl;
  }
    return 0;
  }


# Sources and Sinks (Истоки и стоки)

| | |
| :--- | :--- |
| **Input** | Standard input |
| **Output** | Standard output |

### Problem Statement
In a directed graph:
- A vertex is called a **source** (исток) if no edges enter it (in-degree is 0).
- A vertex is called a **sink** (сток) if no edges leave it (out-degree is 0).

Given the adjacency matrix of a directed graph, find all its sources and sinks.

### Input Format
- The first line contains an integer $n$ ($1 \le n \le 100$) — the number of vertices in the graph.
- The following $n$ lines contain $n$ integers each (0 or 1) — the adjacency matrix of the directed graph.

### Output Format
- **Line 1**: The number of sources $k$, followed by $k$ vertex indices in ascending order.
- **Line 2**: The number of sinks $m$, followed by $m$ vertex indices in ascending order.
*(Vertices are indexed starting from 1)*.

### Examples
| Input | Output |
| :--- | :--- |
| `4` <br> `1 0 0 1` <br> `0 0 0 0` <br> `1 1 0 1` <br> `0 0 0 0` | `1 3` <br> `2 2 4` |

#include <iostream>

#include <vector>

using namespace std;
int main() {
    int n;
    cin >> n;
    
    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> a[i][j];
        }
    }
    vector<int> b;
    vector<int> c;
    
    for (int i = 0; i < n; i++) {
        bool d = true;
        bool e = true;
        
        for (int j = 0; j < n; j++) {
            if (a[i][j] == 1) {
                e = false;
                break;
            }
        }
        
        for (int j = 0; j < n; j++) {
            if (a[j][i] == 1) {
                d = false;
                break;
            }
        }
        
        if (d) b.push_back(i + 1);
        if (e) c.push_back(i + 1);
    }
    
    cout << b.size();
    for (int i = 0; i < b.size(); i++) {
        cout << " " << b[i];
    }
    cout << endl;
    cout << c.size();
    for (int i = 0; i < c.size(); i++) {
        cout << " " << c[i];
    }
    cout << endl; 
    return 0;
}


