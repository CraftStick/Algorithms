# Turtle: Maximum Path Sum (Черепашка: Максимальный путь)

| | |
| :--- | :--- |
| **Input** | Standard input |
| **Output** | Standard output |

### Problem Statement
A turtle is located in the top-left corner of an $N \times M$ grid. Each cell in the table contains an integer. The turtle can move either **right** or **down**. The turtle's journey ends in the bottom-right corner of the grid.

Calculate the sum of the numbers in the cells along the turtle's path (including the starting and ending cells). Find the **maximum possible value** of this sum.

### Input Format
- The first line contains two natural numbers $N$ and $M$ ($N, M \le 100$) — the dimensions of the grid.
- The next $N$ lines each contain $M$ integers ($0 \le \text{value} \le 100$) — the description of the grid.

### Output Format
Print a single integer: the maximum possible cost of the turtle's route.

### Examples
| Input | Output |
| :--- | :--- |
| `3 4` <br> `1 1 2 1` <br> `2 2 1 1` <br> `2 1 2 1` | `9` |

#include <iostream>

using namespace std;

int main() {
    int N, M;
    cin >> N >> M;
    
    int grid[101][101];
    
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= M; j++) {
            cin >> grid[i][j];
        }
    }
    
    int dp[101][101] = {0};
    
    dp[1][1] = grid[1][1];
    for (int j = 2; j <= M; j++) {
        dp[1][j] = dp[1][j-1] + grid[1][j];
    }

    for (int i = 2; i <= N; i++) {
        dp[i][1] = dp[i-1][1] + grid[i][1];
    }
    
    for (int i = 2; i <= N; i++) {
        for (int j = 2; j <= M; j++) {
            if (dp[i-1][j] > dp[i][j-1]) {
                dp[i][j] = dp[i-1][j] + grid[i][j];
            } else {
                dp[i][j] = dp[i][j-1] + grid[i][j];
            }
        }
    }
    
    cout << dp[N][M] << endl;
    
    return 0;
}


# Turtle: Max Sum and Path Reconstruction (Черепашка: Путь и маршрут)

| | |
| :--- | :--- |
| **Input** | Standard input |
| **Output** | Standard output |

### Problem Statement
A turtle is located in the top-left corner of an $N \times M$ grid. Each cell in the grid contains an integer. The turtle can move either **right** (R) or **down** (D). The turtle's journey ends in the bottom-right corner of the grid.

Calculate the maximum possible sum of the numbers in the cells along the path (including the starting and ending cells) and determine the **path** taken to achieve this sum.

### Input Format
- The first line contains two natural numbers $N$ and $M$ ($N, M \le 100$) — the dimensions of the grid.
- The next $N$ lines each contain $M$ integers ($0 \le \text{value} \le 100$) — the cell values.

### Output Format
- **Line 1**: The maximum possible sum of the route.
- **Line 2**: The path represented as a sequence of $N-1$ letters **'D'** (down) and $M-1$ letters **'R'** (right). If multiple such paths exist, output any one of them.

### Examples
| Input | Output |
| :--- | :--- |
| `5 5` <br> `9 9 9 9 9` <br> `3 0 0 0 0` <br> `9 9 9 9 9` <br> `6 6 6 6 8` <br> `9 9 9 9 9` | `74` <br> `D D R R R R D D` |
| `2 2` <br> `1 2` <br> `3 1` | `5` <br> `D R` |

#include <iostream>

using namespace std;

int main() {
    int N, M;
    cin >> N >> M;
    
    int grid[101][101];
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= M; j++) {
            cin >> grid[i][j];
        }
    }
    
    int dp[101][101] = {0};
    dp[1][1] = grid[1][1];
    
    for (int j = 2; j <= M; j++) {
        dp[1][j] = dp[1][j-1] + grid[1][j];
    }
    
    for (int i = 2; i <= N; i++) {
        dp[i][1] = dp[i-1][1] + grid[i][1];
    }
    
    for (int i = 2; i <= N; i++) {
        for (int j = 2; j <= M; j++) {
            if (dp[i-1][j] > dp[i][j-1]) {
                dp[i][j] = dp[i-1][j] + grid[i][j];
            } else {
                dp[i][j] = dp[i][j-1] + grid[i][j];
            }
        }
    }
    
    cout << dp[N][M] << endl;
    
    char path[201];
    int idx = 0;
    int i = N, j = M;
    while (i > 1 || j > 1) {
        if (i > 1 && (j == 1 || dp[i-1][j] >= dp[i][j-1])) {
            path[idx] = 'D';
            i--;
        } else {
            path[idx] = 'R';
            j--;
        }
        idx++;
    }
    
    for (int k = idx - 1; k >= 0; k--) {
        cout << path[k];
        if (k > 0) cout << " ";
    }
    cout << endl;
    
    return 0;
}


# Longest Increasing Subsequence (Наибольшая возрастающая подпоследовательность)

| | |
| :--- | :--- |
| **Input** | Standard input |
| **Output** | Standard output |

### Problem Statement
Given a sequence of integers, find its **Longest Increasing Subsequence** (LIS).

### Input Format
- The first line contains an integer $N$ ($1 \le N \le 1000$) — the length of the sequence.
- The second line contains the sequence of $N$ integers (separated by spaces).
- Each element in the sequence is an integer with an absolute value not exceeding $10,000$.

### Output Format
Print the longest increasing subsequence. If there are multiple such subsequences with the same maximum length, print any one of them.

### Examples
| Input | Output |
| :--- | :--- |
| `6` <br> `3 29 5 5 28 6` | `3 5 28` |

#include <iostream>

using namespace std;

int main() {
    int N;
    cin >> N;
    
    int a[1001];
    for (int i = 1; i <= N; i++) {
        cin >> a[i];
    }
    
    int dp[1001] = {0};
    int prev[1001] = {0};
    
    for (int i = 1; i <= N; i++) {
        dp[i] = 1;
        prev[i] = 0;
        
        for (int j = 1; j < i; j++) {
            if (a[j] < a[i] && dp[j] + 1 > dp[i]) {
                dp[i] = dp[j] + 1;
                prev[i] = j;
            }
        }
    }
    
    int max_len = 0;
    int last_index = 0;
    
    for (int i = 1; i <= N; i++) {
        if (dp[i] > max_len) {
            max_len = dp[i];
            last_index = i;
        }
    }
    
    int path[1001];
    int idx = 0;
    
    int cur = last_index;
    while (cur > 0) {
        path[idx] = a[cur];
        idx++;
        cur = prev[cur];
    }
    
    for (int i = idx - 1; i >= 0; i--) {
        cout << path[i];
        if (i > 0) cout << " ";
    }
    cout << endl;
    
    return 0;
}


# Longest Common Subsequence (Наибольшая общая подпоследовательность)

| | |
| :--- | :--- |
| **Input** | Standard input |
| **Output** | Standard output |

### Problem Statement
Given two sequences of integers, find and output their **Longest Common Subsequence** (LCS).

### Input Format
- **Line 1**: An integer $N$ ($1 \le N \le 1000$) — the length of the first sequence.
- **Line 2**: $N$ integers representing the first sequence (absolute values $\le 10,000$).
- **Line 3**: An integer $M$ ($1 \le M \le 1000$) — the length of the second sequence.
- **Line 4**: $M$ integers representing the second sequence (absolute values $\le 10,000$).

### Output Format
Print the integers forming the longest common subsequence, separated by spaces.

### Examples
| Input | Output |
| :--- | :--- |
| `3` <br> `1 2 3` <br> `3` <br> `2 3 1` | `2 3` |

#include <iostream>

using namespace std;

int main() {
    int N, M;
    cin >> N;
    
    int a[1001];
    for (int i = 1; i <= N; i++) {
        cin >> a[i];
    }
    
    cin >> M;
    int b[1001];
    for (int i = 1; i <= M; i++) {
        cin >> b[i];
    }
    
    int dp[1001][1001] = {0};
    
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= M; j++) {
            if (a[i] == b[j]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                if (dp[i-1][j] > dp[i][j-1]) {
                    dp[i][j] = dp[i-1][j];
                } else {
                    dp[i][j] = dp[i][j-1];
                }
            }
        }
    }
    
    int len = dp[N][M];
    int result[1001];
    int idx = len;
    
    int i = N, j = M;
    while (i > 0 && j > 0) {
        if (a[i] == b[j]) {
            result[idx] = a[i];
            idx--;
            i--;
            j--;
        } else if (dp[i-1][j] > dp[i][j-1]) {
            i--;
        } else {
            j--;
        }
    }
    
    for (int k = 1; k <= len; k++) {
        cout << result[k];
        if (k < len) 
          cout << " ";
    }
    cout << endl;
    
    return 0;
}


